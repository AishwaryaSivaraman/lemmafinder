{"optimize_0plus_sound": "Theorem optimize_0plus_sound: forall a,  aeval (optimize_0plus a) = aeval a.", "silly1": "Theorem silly1 : forall n,  1 + n = S n.", "silly2": "Theorem silly2 : forall (P : Prop), P -> P.", "foo": "Lemma foo : forall n, 0 <=? n = true.", "foo'": "Lemma foo' : forall n, 0 <=? n = true.", "optimize_0plus_sound'": "Theorem optimize_0plus_sound': forall a,  aeval (optimize_0plus a) = aeval a.", "optimize_0plus_sound''": "Theorem optimize_0plus_sound'': forall a,  aeval (optimize_0plus a) = aeval a.", "In10": "Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].", "In10'": "Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].", "repeat_loop": "Theorem repeat_loop : forall (m n : nat),    m + n = n + m.", "optimize_0plus_b_sound": "Theorem optimize_0plus_b_sound : forall b,  beval (optimize_0plus_b b) = beval b.", "aeval_iff_aevalR": "Theorem aeval_iff_aevalR : forall a n,  (a ==> n) <-> aeval a = n.", "aeval_iff_aevalR'": "Theorem aeval_iff_aevalR' : forall a n,  (a ==> n) <-> aeval a = n.", "beval_iff_bevalR": "Lemma beval_iff_bevalR : forall b bv,  b ==>b bv <-> beval b = bv.", "pup_to_2_ceval": "Theorem pup_to_2_ceval :  (X !-> 2) =[    pup_to_n  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).", "ceval_deterministic": "Theorem ceval_deterministic: forall c st st1 st2,    st =[ c ]=> st1  ->    st =[ c ]=> st2 ->    st1 = st2.", "plus2_spec": "Theorem plus2_spec : forall st n st',  st X = n ->  st =[ plus2 ]=> st' ->  st' X = n + 2.", "loop_never_stops": "Theorem loop_never_stops : forall st st',  ~(st =[ loop ]=> st').", "no_whiles_eqv": "Theorem no_whiles_eqv:   forall c, no_whiles c = true <-> no_whilesR c.", "execute_app": "Theorem execute_app : forall st p1 p2 stack,    s_execute st stack (p1 ++ p2) = s_execute st (s_execute st stack p1) p2.", "s_compile_correct_aux": "Lemma s_compile_correct_aux : forall st e stack,  s_execute st stack (s_compile e) = aeval st e :: stack.", "s_compile_correct": "Theorem s_compile_correct : forall (st : state) (e : aexp),  s_execute st [] (s_compile e) = [ aeval st e ].", "break_ignore": "Theorem break_ignore : forall c st st' s,     st =[ break; c ]=> st' / s ->     st = st'.", "while_continue": "Theorem while_continue : forall b c st st' s,  st =[ while b do c end ]=> st' / s ->  s = SContinue.", "while_stops_on_break": "Theorem while_stops_on_break : forall b c st st',  beval st b = true ->  st =[ c ]=> st' / SBreak ->  st =[ while b do c end ]=> st' / SContinue.", "while_break_true": "Theorem while_break_true : forall b c st st',  st =[ while b do c end ]=> st' / SContinue ->  beval st' b = true ->  exists st'', st'' =[ c ]=> st' / SBreak.", "ev_4": "Theorem ev_4 : ev 4.", "ev_4'": "Theorem ev_4': ev 4.", "ev_plus4": "Theorem ev_plus4 : forall n, ev n -> ev (4 + n).", "ev_double": "Theorem ev_double : forall n,  ev (double n).", "ev_inversion": "Theorem ev_inversion :  forall (n : nat), ev n ->    (n = 0) \\/ (exists n', n = S (S n') /\\ ev n').", "ev_minus2": "Theorem ev_minus2 : forall n,  ev n -> ev (pred (pred n)).", "evSS_ev": "Theorem evSS_ev : forall n, ev (S (S n)) -> ev n.", "evSS_ev_remember": "Theorem evSS_ev_remember : forall n,  ev (S (S n)) -> ev n.", "evSS_ev'": "Theorem evSS_ev' : forall n,  ev (S (S n)) -> ev n.", "one_not_even": "Theorem one_not_even : ~ ev 1.", "SSSSev__even": "Theorem SSSSev__even : forall n,  ev (S (S (S (S n)))) -> ev n.", "ev5_nonsense": "Theorem ev5_nonsense :  ev 5 -> 2 + 2 = 9.", "inversion_ex1": "Theorem inversion_ex1 : forall (n m o : nat),  [n; m] = [o; o] ->  [n] = [m].", "inversion_ex2": "Theorem inversion_ex2 : forall (n : nat),  S n = O ->  2 + 2 = 5.", "ev_even_firsttry": "Lemma ev_even_firsttry : forall n,  ev n -> even n.", "ev_even": "Lemma ev_even : forall n,  ev n -> even n.", "ev_even_iff": "Theorem ev_even_iff : forall n,  ev n <-> even n.", "ev_sum": "Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).", "ev'_ev": "Theorem ev'_ev : forall n, ev' n <-> ev n.", "ev_ev__ev": "Theorem ev_ev__ev : forall n m,  ev (n+m) -> ev n -> ev m.", "ev_plus_plus": "Theorem ev_plus_plus : forall n m p,  ev (n+m) -> ev (n+p) -> ev (m+p).", "test_le1": "Theorem test_le1 :  3 <= 3.", "test_le2": "Theorem test_le2 :  3 <= 6.", "test_le3": "Theorem test_le3 :  (2 <= 1) -> 2 + 2 = 5.", "le_trans": "Theorem le_trans :  transitive le.", "O_le_n": "Theorem O_le_n : forall n,  0 <= n.", "n_le_m__Sn_le_Sm": "Theorem n_le_m__Sn_le_Sm : forall n m,  n <= m -> S n <= S m.", "Sn_le_Sm__n_le_m": "Theorem Sn_le_Sm__n_le_m : forall n m,  S n <= S m -> n <= m.", "le_plus_l": "Theorem le_plus_l : forall a b,  a <= a + b.", "plus_le": "Theorem plus_le : forall n1 n2 m,  n1 + n2 <= m ->  n1 <= m /\\ n2 <= m.", "add_le_cases": "Theorem add_le_cases : forall n m p q,    n + m <= p + q -> n <= p \\/ m <= q.", "lt_S": "Theorem lt_S : forall n m,  n < m ->  n < S m.", "plus_lt": "Theorem plus_lt : forall n1 n2 m,  n1 + n2 < m ->  n1 < m /\\ n2 < m.", "leb_complete": "Theorem leb_complete : forall n m,  n <=? m = true -> n <= m.", "leb_correct": "Theorem leb_correct : forall n m,  n <= m ->  n <=? m = true.", "leb_true_trans": "Theorem leb_true_trans : forall n m o,  n <=? m = true -> m <=? o = true -> n <=? o = true.", "leb_iff": "Theorem leb_iff : forall n m,  n <=? m = true <-> n <= m.", "R_equiv_fR": "Theorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o.", "subseq_refl": "Theorem subseq_refl : forall (l : list nat), subseq l l.", "subseq_app": "Theorem subseq_app : forall (l1 l2 l3 : list nat),  subseq l1 l2 ->  subseq l1 (l2 ++ l3).", "subseq_trans": "Theorem subseq_trans : forall (l1 l2 l3 : list nat),  subseq l1 l2 ->  subseq l2 l3 ->  subseq l1 l3.", "quiz": "Lemma quiz : forall T (s:list T), ~(s =~ EmptySet).", "MStar1": "Lemma MStar1 :  forall T s (re : reg_exp T) ,    s =~ re ->    s =~ Star re.", "empty_is_empty": "Lemma empty_is_empty : forall T (s : list T),  ~ (s =~ EmptySet).", "MUnion'": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),  s =~ re1 \\/ s =~ re2 ->  s =~ Union re1 re2.", "MStar'": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),  (forall s, In s ss -> s =~ re) ->  fold app ss [] =~ Star re.", "reg_exp_of_list_spec": "Lemma reg_exp_of_list_spec : forall T (s1 s2 : list T),  s1 =~ reg_exp_of_list s2 <-> s1 = s2.", "in_re_match": "Theorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),  s =~ re ->  In x s ->  In x (re_chars re).", "re_not_empty_correct": "Lemma re_not_empty_correct : forall T (re : reg_exp T),  (exists s, s =~ re) <-> re_not_empty re = true.", "star_app": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),  s1 =~ Star re ->  s2 =~ Star re ->  s1 ++ s2 =~ Star re.", "MStar''": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),  s =~ Star re ->  exists ss : list (list T),    s = fold app ss []    /\\ forall s', In s' ss -> s' =~ re.", "pumping_constant_ge_1": "Lemma pumping_constant_ge_1 :  forall T (re : reg_exp T),    pumping_constant re >= 1.", "pumping_constant_0_false": "Lemma pumping_constant_0_false :  forall T (re : reg_exp T),    pumping_constant re = 0 -> False.", "napp_plus": "Lemma napp_plus: forall T (n m : nat) (l : list T),  napp (n + m) l = napp n l ++ napp m l.", "napp_star": "Lemma napp_star :  forall T m s1 s2 (re : reg_exp T),    s1 =~ re -> s2 =~ Star re ->    napp m s1 ++ s2 =~ Star re.", "weak_pumping": "Lemma weak_pumping : forall T (re : reg_exp T) s,  s =~ re ->  pumping_constant re <= length s ->  exists s1 s2 s3,    s = s1 ++ s2 ++ s3 /\\    s2 <> [] /\\    forall m, s1 ++ napp m s2 ++ s3 =~ re.", "pumping": "Lemma pumping : forall T (re : reg_exp T) s,  s =~ re ->  pumping_constant re <= length s ->  exists s1 s2 s3,    s = s1 ++ s2 ++ s3 /\\    s2 <> [] /\\    length s1 + length s2 <= pumping_constant re /\\    forall m, s1 ++ napp m s2 ++ s3 =~ re.", "filter_not_empty_In": "Theorem filter_not_empty_In : forall n l,  filter (fun x => n =? x) l <> [] ->  In n l.", "iff_reflect": "Theorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.", "reflect_iff": "Theorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).", "eqbP": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).", "filter_not_empty_In'": "Theorem filter_not_empty_In' : forall n l,  filter (fun x => n =? x) l <> [] ->  In n l.", "eqbP_practice": "Theorem eqbP_practice : forall n l,  count n l = 0 -> ~(In n l).", "in_split": "Lemma in_split : forall (X:Type) (x:X) (l:list X),  In x l ->  exists l1 l2, l = l1 ++ x :: l2.", "pigeonhole_principle": "Theorem pigeonhole_principle: forall (X:Type) (l1  l2:list X),   excluded_middle ->   (forall x, In x l1 -> In x l2) ->   length l2 < length l1 ->   repeats l1.", "provable_equiv_true": "Lemma provable_equiv_true : forall (P : Prop), P -> (P <-> True).", "not_equiv_false": "Lemma not_equiv_false : forall (P : Prop), ~P -> (P <-> False).", "null_matches_none": "Lemma null_matches_none : forall (s : string), (s =~ EmptySet) <-> False.", "empty_matches_eps": "Lemma empty_matches_eps : forall (s : string), s =~ EmptyStr <-> s = [ ].", "empty_nomatch_ne": "Lemma empty_nomatch_ne : forall (a : ascii) s, (a :: s =~ EmptyStr) <-> False.", "char_nomatch_char": "Lemma char_nomatch_char :  forall (a b : ascii) s, b <> a -> (b :: s =~ Char a <-> False).", "char_eps_suffix": "Lemma char_eps_suffix : forall (a : ascii) s, a :: s =~ Char a <-> s = [ ].", "app_exists": "Lemma app_exists : forall (s : string) re0 re1,    s =~ App re0 re1 <->    exists s0 s1, s = s0 ++ s1 /\\ s0 =~ re0 /\\ s1 =~ re1.", "app_ne": "Lemma app_ne : forall (a : ascii) s re0 re1,    a :: s =~ (App re0 re1) <->    ([ ] =~ re0 /\\ a :: s =~ re1) \\/    exists s0 s1, s = s0 ++ s1 /\\ a :: s0 =~ re0 /\\ s1 =~ re1.", "union_disj": "Lemma union_disj : forall (s : string) re0 re1,    s =~ Union re0 re1 <-> s =~ re0 \\/ s =~ re1.", "star_ne": "Lemma star_ne : forall (a : ascii) s re,    a :: s =~ Star re <->    exists s0 s1, s = s0 ++ s1 /\\ a :: s0 =~ re /\\ s1 =~ Star re.", "match_eps_refl": "Lemma match_eps_refl : refl_matches_eps match_eps.", "derive_corr": "Lemma derive_corr : derives derive.", "regex_refl": "Theorem regex_refl : matches_regex regex_match.", "app_nil_r": "Theorem app_nil_r : forall l : natlist,  l ++ [] = l.", "app_assoc": "Theorem app_assoc : forall l1 l2 l3 : natlist,  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).", "app_length": "Theorem app_length : forall l1 l2 : natlist,  length (l1 ++ l2) = (length l1) + (length l2).", "rev_app_distr": "Theorem rev_app_distr: forall l1 l2 : natlist,  rev (l1 ++ l2) = rev l2 ++ rev l1.", "rev_involutive": "Theorem rev_involutive : forall l : natlist,  rev (rev l) = l.", "map_app": "Lemma map_app : forall (X Y : Type) (f : X -> Y) (l : list X) (x : X),map f (rev l ++ [x]) = map f (rev l) ++ [f x].", "map_rev": "  Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),    map f (rev l) = rev (map f l).", "fold_length_correct": "Theorem fold_length_correct : forall X (l : list X),  fold_length l = length l.", "uncurry_curry": "Theorem uncurry_curry : forall (X Y Z : Type)                        (f : X -> Y -> Z)                        x y,  prod_curry (prod_uncurry f) x y = f x y.", "curry_uncurry": "Theorem curry_uncurry : forall (X Y Z : Type)                        (f : (X * Y) -> Z) (p : X * Y),  prod_uncurry (prod_curry f) p = f p.", "ceval_step__ceval": "Theorem ceval_step__ceval: forall c st st',      (exists i, ceval_step st c i = Some st') ->      st =[ c ]=> st'.", "ceval_step_more": "Theorem ceval_step_more: forall i1 i2 st st' c,  i1 <= i2 ->  ceval_step st c i1 = Some st' ->  ceval_step st c i2 = Some st'.", "ceval__ceval_step": "Theorem ceval__ceval_step: forall c st st',      st =[ c ]=> st' ->      exists i, ceval_step st c i = Some st'.", "ceval_and_ceval_step_coincide": "Theorem ceval_and_ceval_step_coincide: forall c st st',      st =[ c ]=> st'  <-> exists i, ceval_step st c i = Some st'.", "ceval_deterministic'": "Theorem ceval_deterministic': forall c st st1 st2,    st =[ c ]=> st1  ->    st =[ c ]=> st2 ->    st1 = st2.", "plus_2_2_is_4": "Theorem plus_2_2_is_4 :  2 + 2 = 4.", "plus_claim_is_true": "Theorem plus_claim_is_true :  plus_claim.", "succ_inj": "Lemma succ_inj : injective S.", "and_intro": "Lemma and_intro : forall A B : Prop, A -> B -> A /\\ B.", "and_example2": "Lemma and_example2 :  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.", "and_example2'": "Lemma and_example2' :  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.", "and_example2''": "Lemma and_example2'' :  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.", "and_example3": "Lemma and_example3 :  forall n m : nat, n + m = 0 -> n * m = 0.", "proj1": "Lemma proj1 : forall P Q : Prop,  P /\\ Q -> P.", "proj2": "Lemma proj2 : forall P Q : Prop,  P /\\ Q -> Q.", "and_commut": "Theorem and_commut : forall P Q : Prop,  P /\\ Q -> Q /\\ P.", "and_assoc": "Theorem and_assoc : forall P Q R : Prop,  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.", "eq_mult_0": "Lemma eq_mult_0 :  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.", "or_intro_l": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.", "zero_or_succ": "Lemma zero_or_succ :  forall n : nat, n = 0 \\/ n = S (pred n).", "mult_eq_0": "Lemma mult_eq_0 :  forall n m, n * m = 0 -> n = 0 \\/ m = 0.", "or_commut": "Theorem or_commut : forall P Q : Prop,  P \\/ Q  -> Q \\/ P.", "ex_falso_quodlibet": "Theorem ex_falso_quodlibet : forall (P:Prop),  False -> P.", "zero_not_one": "Theorem zero_not_one : 0 <> 1.", "not_False": "Theorem not_False :  ~ False.", "contradiction_implies_anything": "Theorem contradiction_implies_anything : forall P Q : Prop,  (P /\\ ~P) -> Q.", "double_neg": "Theorem double_neg : forall P : Prop,  P -> ~~P.", "contrapositive": "Theorem contrapositive : forall (P Q : Prop),  (P -> Q) -> (~Q -> ~P).", "not_both_true_and_false": "Theorem not_both_true_and_false : forall P : Prop,  ~ (P /\\ ~P).", "not_true_is_false": "Theorem not_true_is_false : forall b : bool,  b <> true -> b = false.", "not_true_is_false'": "Theorem not_true_is_false' : forall b : bool,  b <> true -> b = false.", "True_is_true": "Lemma True_is_true : True.", "iff_sym": "Theorem iff_sym : forall P Q : Prop,  (P <-> Q) -> (Q <-> P).", "not_true_iff_false": "Lemma not_true_iff_false : forall b,  b <> true <-> b = false.", "iff_refl": "Theorem iff_refl : forall P : Prop,  P <-> P.", "iff_trans": "Theorem iff_trans : forall P Q R : Prop,  (P <-> Q) -> (Q <-> R) -> (P <-> R).", "or_distributes_over_and": "Theorem or_distributes_over_and : forall P Q R : Prop,  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).", "mult_0": "Lemma mult_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.", "or_assoc": "Theorem or_assoc :  forall P Q R : Prop, P \\/ (Q \\/ R) <-> (P \\/ Q) \\/ R.", "mult_0_3": "Lemma mult_0_3 :  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.", "apply_iff_example": "Lemma apply_iff_example :  forall n m : nat, n * m = 0 -> n = 0 \\/ m = 0.", "four_is_even": "Lemma four_is_even : even 4.", "exists_example_2": "Theorem exists_example_2 : forall n,  (exists m, n = 4 + m) ->  (exists o, n = 2 + o).", "dist_not_exists": "Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),  (forall x, P x) -> ~ (exists x, ~ P x).", "dist_exists_or": "Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),  (exists x, P x \\/ Q x) <-> (exists x, P x) \\/ (exists x, Q x).", "In_map": "Theorem In_map :  forall (A B : Type) (f : A -> B) (l : list A) (x : A),    In x l ->    In (f x) (map f l).", "In_map_iff": "Theorem In_map_iff :  forall (A B : Type) (f : A -> B) (l : list A) (y : B),    In y (map f l) <->    exists x, f x = y /\\ In x l.", "In_app_iff": "Theorem In_app_iff : forall A l l' (a:A),  In a (l++l') <-> In a l \\/ In a l'.", "All_In": "Theorem All_In :  forall T (P : T -> Prop) (l : list T),    (forall x, In x l -> P x) <->    All P l.", "combine_odd_even_intro": "Theorem combine_odd_even_intro :  forall (Podd Peven : nat -> Prop) (n : nat),    (oddb n = true -> Podd n) ->    (oddb n = false -> Peven n) ->    combine_odd_even Podd Peven n.", "combine_odd_even_elim_odd": "Theorem combine_odd_even_elim_odd :  forall (Podd Peven : nat -> Prop) (n : nat),    combine_odd_even Podd Peven n ->    oddb n = true ->    Podd n.", "combine_odd_even_elim_even": "Theorem combine_odd_even_elim_even :  forall (Podd Peven : nat -> Prop) (n : nat),    combine_odd_even Podd Peven n ->    oddb n = false ->    Peven n.", "plus_comm3": "Lemma plus_comm3 :  forall x y z, x + (y + z) = (z + y) + x.(** It appears at first sight that we ought to be able to prove this    by rewriting with [plus_comm] twice to make the two sides match.    The problem, however, is that the second [rewrite] will undo the    effect of the first. *)", "plus_comm3_take2": "Lemma plus_comm3_take2 :  forall x y z, x + (y + z) = (z + y) + x.", "plus_comm3_take3": "Lemma plus_comm3_take3 :  forall x y z, x + (y + z) = (z + y) + x.", "in_not_nil": "Theorem in_not_nil :  forall A (x : A) (l : list A), In x l -> l <> [].", "in_not_nil_42": "Lemma in_not_nil_42 :  forall l : list nat, In 42 l -> l <> [].", "in_not_nil_42_take2": "Lemma in_not_nil_42_take2 :  forall l : list nat, In 42 l -> l <> [].", "in_not_nil_42_take3": "Lemma in_not_nil_42_take3 :  forall l : list nat, In 42 l -> l <> [].", "in_not_nil_42_take4": "Lemma in_not_nil_42_take4 :  forall l : list nat, In 42 l -> l <> [].", "in_not_nil_42_take5": "Lemma in_not_nil_42_take5 :  forall l : list nat, In 42 l -> l <> [].", "tr_rev_correct": "Theorem tr_rev_correct : forall X, @tr_rev X = @rev X.", "evenb_double": "Lemma evenb_double : forall k, evenb (double k) = true.", "evenb_double_conv": "Lemma evenb_double_conv : forall n, exists k,  n = if evenb n then double k else S (double k).", "even_bool_prop": "Theorem even_bool_prop : forall n,  evenb n = true <-> even n.", "eqb_eq": "Theorem eqb_eq : forall n1 n2 : nat,  n1 =? n2 = true <-> n1 = n2.", "plus_eqb_example": "Lemma plus_eqb_example : forall n m p : nat,    n =? m = true -> n + p =? m + p = true.", "andb_true_iff": "Theorem andb_true_iff : forall b1 b2:bool,  b1 && b2 = true <-> b1 = true /\\ b2 = true.", "orb_true_iff": "Theorem orb_true_iff : forall b1 b2,  b1 || b2 = true <-> b1 = true \\/ b2 = true.", "eqb_neq": "Theorem eqb_neq : forall x y : nat,  x =? y = false <-> x <> y.", "eqb_list_true_iff": "Theorem eqb_list_true_iff :  forall A (eqb : A -> A -> bool),    (forall a1 a2, eqb a1 a2 = true <-> a1 = a2) ->    forall l1 l2, eqb_list eqb l1 l2 = true <-> l1 = l2.", "forallb_true_iff": "Theorem forallb_true_iff : forall X test (l : list X),   forallb test l = true <-> All (fun x => test x = true) l.", "restricted_excluded_middle": "Theorem restricted_excluded_middle : forall P b,  (P <-> b = true) -> P \\/ ~ P.", "restricted_excluded_middle_eq": "Theorem restricted_excluded_middle_eq : forall (n m : nat),  n = m \\/ n <> m.", "excluded_middle_irrefutable": "Theorem excluded_middle_irrefutable: forall (P:Prop),  ~ ~ (P \\/ ~ P).", "not_exists_dist": "Theorem not_exists_dist :  excluded_middle ->  forall (X:Type) (P : X -> Prop),    ~ (exists x, ~ P x) -> (forall x, P x).", "plus_O_n": "Theorem plus_O_n : forall n : nat, 0 + n = n.", "plus_O_n'": "Theorem plus_O_n' : forall n : nat, 0 + n = n.", "plus_O_n''": "Theorem plus_O_n'' : forall n : nat, 0 + n = n.", "plus_1_l": "Theorem plus_1_l : forall n:nat, 1 + n = S n.", "mult_0_l": "Theorem mult_0_l : forall n:nat, 0 * n = 0.", "plus_id_example": "Theorem plus_id_example : forall n m:nat,  n = m ->  n + n = m + m.(** Instead of making a universal claim about all numbers [n] and [m],    it talks about a more specialized property that only holds when    [n = m].  The arrow symbol is pronounced \"implies.\"    As before, we need to be able to reason by assuming we are given such    numbers [n] and [m].  We also need to assume the hypothesis    [n = m]. The [intros] tactic will serve to move all three of these    from the goal into assumptions in the current context.    Since [n] and [m] are arbitrary numbers, we can't just use    simplification to prove this theorem.  Instead, we prove it by    observing that, if we are assuming [n = m], then we can replace    [n] with [m] in the goal statement and obtain an equality with the    same expression on both sides.  The tactic that tells Coq to    perform this replacement is called [rewrite]. *)", "plus_id_exercise": "Theorem plus_id_exercise : forall n m o : nat,  n = m -> m = o -> n + m = m + o.", "mult_n_0_m_0": "Theorem mult_n_0_m_0 : forall p q : nat,  (p * 0) + (q * 0) = 0.", "mult_n_1": "Theorem mult_n_1 : forall p : nat,  p * 1 = p.", "plus_1_neq_0_firsttry": "Theorem plus_1_neq_0_firsttry : forall n : nat,  (n + 1) =? 0 = false.", "plus_1_neq_0": "Theorem plus_1_neq_0 : forall n : nat,  (n + 1) =? 0 = false.", "negb_involutive": "Theorem negb_involutive : forall b : bool,  negb (negb b) = b.", "andb_commutative": "Theorem andb_commutative : forall b c, andb b c = andb c b.", "andb_commutative'": "Theorem andb_commutative' : forall b c, andb b c = andb c b.", "andb3_exchange": "Theorem andb3_exchange :  forall b c d, andb (andb b c) d = andb (andb b d) c.", "andb_true_elim2": "Theorem andb_true_elim2 : forall b c : bool,  andb b c = true -> c = true.", "plus_1_neq_0'": "Theorem plus_1_neq_0' : forall n : nat,  (n + 1) =? 0 = false.", "andb_commutative''": "Theorem andb_commutative'' :  forall b c, andb b c = andb c b.", "zero_nbeq_plus_1": "Theorem zero_nbeq_plus_1 : forall n : nat,  0 =? (n + 1) = false.", "identity_fn_applied_twice": "Theorem identity_fn_applied_twice :  forall (f : bool -> bool),  (forall (x : bool), f x = x) ->  forall (b : bool), f (f b) = b.", "andb_eq_orb": "Theorem andb_eq_orb :  forall (b c : bool),  (andb b c = orb b c) ->  b = c.", "next_nat_partial_function": "Theorem next_nat_partial_function :   partial_function next_nat.", "le_not_a_partial_function": "Theorem le_not_a_partial_function :  ~ (partial_function le).", "le_reflexive": "Theorem le_reflexive :  reflexive le.", "lt_trans": "Theorem lt_trans:  transitive lt.", "lt_trans'": "Theorem lt_trans' :  transitive lt.", "lt_trans''": "Theorem lt_trans'' :  transitive lt.", "le_Sn_le": "Theorem le_Sn_le : forall n m, S n <= m -> n <= m.", "le_S_n": "Theorem le_S_n : forall n m,  (S n <= S m) -> (n <= m).", "For": "   Theorem: For any [nat]s [n] [m], [(n =? m) = (m =? n)].", "le_Sn_n": "Theorem le_Sn_n : forall n,  ~ (S n <= n).", "le_not_symmetric": "Theorem le_not_symmetric :  ~ (symmetric le).", "le_antisymmetric": "Theorem le_antisymmetric :  antisymmetric le.", "le_step": "Theorem le_step : forall n m p,  n < m ->  m <= S p ->  n <= p.", "le_order": "Theorem le_order :  order le.", "next_nat_closure_is_le": "Theorem next_nat_closure_is_le : forall n m,  (n <= m) <-> ((clos_refl_trans next_nat) n m).", "rsc_R": "Lemma rsc_R : forall (X:Type) (R:relation X) (x y : X),       R x y -> clos_refl_trans_1n R x y.", "rsc_trans": "Lemma rsc_trans :  forall (X:Type) (R: relation X) (x y z : X),      clos_refl_trans_1n R x y  ->      clos_refl_trans_1n R y z ->      clos_refl_trans_1n R x z.", "rtc_rsc_coincide": "Theorem rtc_rsc_coincide :         forall (X:Type) (R: relation X) (x y : X),  clos_refl_trans R x y <-> clos_refl_trans_1n R x y.", "mult_0_r'": "Theorem mult_0_r' : forall n:nat,  n * 0 = 0.", "plus_one_r'": "Theorem plus_one_r' : forall n:nat,  n + 1 = S n.", "mult_0_r''": "Theorem mult_0_r'' : forall n:nat,  P_m0r n.", "plus_assoc'": "Theorem plus_assoc' : forall n m p : nat,  n + (m + p) = (n + m) + p.", "plus_comm'": "Theorem plus_comm' : forall n m : nat,  n + m = m + n.", "plus_comm''": "Theorem plus_comm'' : forall n m : nat,  n + m = m + n.", "ev''_ev'": "Theorem ev''_ev' : forall n, ev'' n -> ev' n.", "evenb_ev": "Lemma evenb_ev : forall n, evenb n = true -> ev'' n.", "eqb_string_refl": "Theorem eqb_string_refl : forall s : string, true = eqb_string s s.", "eqb_string_true_iff": "Theorem eqb_string_true_iff : forall x y : string,    eqb_string x y = true <-> x = y.", "eqb_string_false_iff": "Theorem eqb_string_false_iff : forall x y : string,    eqb_string x y = false <-> x <> y.", "false_eqb_string": "Theorem false_eqb_string : forall x y : string,   x <> y -> eqb_string x y = false.", "t_apply_empty": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),    (_ !-> v) x = v.", "t_update_eq": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,    (x !-> v ; m) x = v.", "t_update_neq": "Theorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,    x1 <> x2 ->    (x1 !-> v ; m) x2 = m x2.", "t_update_shadow": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,    (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).", "eqb_stringP": "Lemma eqb_stringP : forall x y : string,    reflect (x = y) (eqb_string x y).", "t_update_same": "Theorem t_update_same : forall (A : Type) (m : total_map A) x,    (x !-> m x ; m) = m.", "t_update_permute": "Theorem t_update_permute : forall (A : Type) (m : total_map A)                                  v1 v2 x1 x2,    x2 <> x1 ->    (x1 !-> v1 ; x2 !-> v2 ; m)    =    (x2 !-> v2 ; x1 !-> v1 ; m).", "apply_empty": "Lemma apply_empty : forall (A : Type) (x : string),    @empty A x = None.", "update_eq": "Theorem update_eq :  forall (d : partial_map) (x : id) (v: nat),    find x (update d x v) = Some v.", "update_neq": "Theorem update_neq :  forall (d : partial_map) (x y : id) (o: nat),    eqb_id x y = false -> find x (update d y o) = find x d.", "update_shadow": "Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,    (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).", "update_same": "Theorem update_same : forall (A : Type) (m : partial_map A) x v,    m x = Some v ->    (x |-> v ; m) = m.", "update_permute": "Theorem update_permute : forall (A : Type) (m : partial_map A)                                x1 x2 v1 v2,    x2 <> x1 ->    (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).", "inclusion_update": "Lemma inclusion_update : forall (A : Type) (m m': partial_map A)                              x vx,  inclusion m m' ->  inclusion (x |-> vx ; m) (x |-> vx ; m').", "silly2a": "Theorem silly2a : forall (n m : nat),     (n,n) = (m,m)  ->     (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->     [n] = [m].", "silly_ex": "Theorem silly_ex :     (forall n, evenb n = true -> oddb (S n) = true) ->     evenb 2 = true ->     oddb 3 = true.", "silly3_firsttry": "Theorem silly3_firsttry : forall (n : nat),     true = (n =? 5)  ->     (S (S n)) =? 7 = true.", "rev_exercise1": "Theorem rev_exercise1 : forall (l l' : list nat),     l = rev l' ->     l' = rev l.", "trans_eq": "Theorem trans_eq : forall (X:Type) (n m o : X),  n = m -> m = o -> n = o.", "S_injective": "Theorem S_injective : forall (n m : nat),  S n = S m ->  n = m.", "S_injective'": "Theorem S_injective' : forall (n m : nat),  S n = S m ->  n = m.", "injection_ex1": "Theorem injection_ex1 : forall (n m o : nat),  [n; m] = [o; o] ->  [n] = [m].", "injection_ex2": "Theorem injection_ex2 : forall (n m o : nat),  [n; m] = [o; o] ->  [n] = [m].", "eqb_0_l": "Theorem eqb_0_l : forall n,   0 =? n = true -> n = 0.", "discriminate_ex1": "Theorem discriminate_ex1 : forall (n : nat),  S n = O ->  2 + 2 = 5.", "discriminate_ex2": "Theorem discriminate_ex2 : forall (n m : nat),  false = true ->  [n] = [m].", "f_equal": "Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),  x = y -> f x = f y.", "eq_implies_succ_equal": "Theorem eq_implies_succ_equal : forall (n m : nat),    n = m -> S n = S m.", "eq_implies_succ_equal'": "Theorem eq_implies_succ_equal' : forall (n m : nat),    n = m -> S n = S m.", "S_inj": "Theorem S_inj : forall (n m : nat) (b : bool),     (S n) =? (S m) = b  ->     n =? m = b.", "silly3'": "Theorem silly3' : forall (n : nat),  (n =? 5 = true -> (S (S n)) =? 7 = true) ->  true = (n =? 5)  ->  true = ((S (S n)) =? 7).", "double_injective_FAILED": "Theorem double_injective_FAILED : forall n m,     double n = double m ->     n = m.", "double_injective": "Theorem double_injective : forall n m,     double n = double m ->     n = m.", "eqb_true": "Theorem eqb_true : forall n m,    n =? m = true -> n = m.", "plus_n_n_injective": "Theorem plus_n_n_injective : forall n m,     n + n = m + m ->     n = m.", "double_injective_take2_FAILED": "Theorem double_injective_take2_FAILED : forall n m,     double n = double m ->     n = m.", "double_injective_take2": "Theorem double_injective_take2 : forall n m,     double n = double m ->     n = m.", "nth_error_after_last": "Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),     length l = n ->     nth_error l n = None.", "square_mult": "Lemma square_mult : forall n m, square (n * m) = square n * square m.", "sillyfun_false": "Theorem sillyfun_false : forall (n : nat),  sillyfun n = false.", "combine_split": "Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2,  split l = (l1, l2) ->  combine l1 l2 = l.", "sillyfun1_odd_FAILED": "Theorem sillyfun1_odd_FAILED : forall (n : nat),     sillyfun1 n = true ->     oddb n = true.", "sillyfun1_odd": "Theorem sillyfun1_odd : forall (n : nat),     sillyfun1 n = true ->     oddb n = true.", "bool_fn_applied_thrice": "Theorem bool_fn_applied_thrice :  forall (f : bool -> bool) (b : bool),  f (f (f b)) = f b.", "eqb_sym": "Theorem eqb_sym : forall (n m : nat),  (n =? m) = (m =? n).", "eqb_trans": "Theorem eqb_trans : forall n m p,  n =? m = true ->  m =? p = true ->  n =? p = true.", "split_combine": "Theorem split_combine : split_combine_statement.", "filter_exercise": "Theorem filter_exercise : forall (X : Type) (test : X -> bool)                             (x : X) (l lf : list X),     filter test l = x :: lf ->     test x = true.", "existsb_existsb'": "Theorem existsb_existsb' : forall (X : Type) (test : X -> bool) (l : list X),  existsb test l = existsb' test l.", "le_antisym": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.", "ceval_deterministic'_alt": "Theorem ceval_deterministic'_alt: forall c st st1 st2,    st =[ c ]=> st1 ->    st =[ c ]=> st2 ->    st1 = st2.", "ceval_deterministic''": "Theorem ceval_deterministic'': forall c st st1 st2,    st =[ c ]=> st1  ->    st =[ c ]=> st2 ->    st1 = st2.", "ceval_deterministic'''": "Theorem ceval_deterministic''': forall c st st1 st2,    st =[ c ]=> st1  ->    st =[ c ]=> st2 ->    st1 = st2.", "ceval_deterministic'''''": "Theorem ceval_deterministic''''': forall c st st1 st2,    st =[ c ]=> st1  ->    st =[ c ]=> st2 ->    st1 = st2.", "silly2_fixed": "Lemma silly2_fixed :  forall (P : nat -> nat -> Prop) (Q : nat -> Prop),  (exists y, P 42 y) ->  (forall x y : nat, P x y -> Q x) ->  Q 42.", "silly2_eassumption": "Lemma silly2_eassumption : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),  (exists y, P 42 y) ->  (forall x y : nat, P x y -> Q x) ->  Q 42.", "silly2_eauto": "Lemma silly2_eauto : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),  (exists y, P 42 y) ->  (forall x y : nat, P x y -> Q x) ->  Q 42.", "ev_4''": "Theorem ev_4'' : ev 4.", "ev_8": "Theorem ev_8 : ev 8.", "proj1'": "Theorem proj1' : forall P Q,    P /\\ Q -> P.", "and_comm": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.", "inj_l'": "Theorem inj_l' : forall (P Q : Prop), P -> P \\/ Q.", "or_elim'": "Theorem or_elim' : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R.", "four": "Lemma four: 2 + 2 == 1 + 3.", "equality__leibniz_equality": "Lemma equality__leibniz_equality : forall (X : Type) (x y: X),  x == y -> forall P:X->Prop, P x -> P y.", "leibniz_equality__equality": "Lemma leibniz_equality__equality : forall (X : Type) (x y: X),  (forall P:X->Prop, P x -> P y) -> x == y.", "re_opt_e_match": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,    s =~ re -> s =~ re_opt_e re.", "re_opt_e_match'": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,    s =~ re -> s =~ re_opt_e re.", "re_opt_e_match''": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,    s =~ re -> s =~ re_opt_e re.", "re_opt_match": "Lemma re_opt_match : forall T (re: reg_exp T) s,    s =~ re -> s =~ re_opt re.", "re_opt_match'": "Lemma re_opt_match' : forall T (re: reg_exp T) s,    s =~ re -> s =~ re_opt re.", "plus_n_O_firsttry": "Theorem plus_n_O_firsttry : forall n:nat,  n = n + 0.(** ... can't be done in the same simple way.  Just applying  [reflexivity] doesn't work, since the [n] in [n + 0] is an arbitrary  unknown number, so the [match] in the definition of [+] can't be  simplified.  *)", "plus_n_O_secondtry": "Theorem plus_n_O_secondtry : forall n:nat,  n = n + 0.", "plus_n_O": "Theorem plus_n_O : forall n:nat, n = n + 0.", "minus_n_n": "Theorem minus_n_n : forall n,  minus n n = 0.", "mult_0_r": "Theorem mult_0_r : forall n:nat,  n * 0 = 0.", "plus_n_Sm": "Theorem plus_n_Sm : forall n m : nat,  S (n + m) = n + (S m).", "plus_comm": "Theorem plus_comm : forall n m : nat,  n + m = m + n.", "plus_assoc": "Theorem plus_assoc : forall n m p : nat,  n + (m + p) = (n + m) + p.", "double_plus": "Lemma double_plus : forall n, double n = n + n .", "evenb_S": "Theorem evenb_S : forall n : nat,  evenb (S n) = negb (evenb n).", "mult_0_plus'": "Theorem mult_0_plus' : forall n m : nat,  (0 + n) * m = n * m.", "plus_rearrange_firsttry": "Theorem plus_rearrange_firsttry : forall n m p q : nat,  (n + m) + (p + q) = (m + n) + (p + q).", "plus_rearrange": "Theorem plus_rearrange : forall n m p q : nat,  (n + m) + (p + q) = (m + n) + (p + q).", "plus_assoc''": "Theorem plus_assoc'' : forall n m p : nat,  n + (m + p) = (n + m) + p.", "Addition": "    Theorem: Addition is commutative.", "[true": "    Theorem: [true = n =? n] for any [n].", "plus_swap": "Theorem plus_swap : forall n m p : nat,  n + (m + p) = m + (n + p).", "mult_r_0": "    Theorem mult_r_0 : forall n:nat,    0 * n = 0.", "mult_left_distr": "  Lemma mult_left_distr : forall m n p : nat,    m * (p + n) = m * p + m * n.", "mult_right_distr": "  Lemma mult_right_distr : forall m n p : nat,    (p + n) * m = m * p + m * n.", "mult_comm": "  Theorem mult_comm : forall m n : nat,    m * n = n * m.", "leb_refl": "Theorem leb_refl : forall n:nat,  true = (n <=? n).", "zero_nbeq_S": "Theorem zero_nbeq_S : forall n:nat,  0 =? (S n) = false.", "andb_false_r": "Theorem andb_false_r : forall b : bool,  andb b false = false.", "plus_ble_compat_l": "Theorem plus_ble_compat_l : forall n m p : nat,  n <=? m = true -> (p + n) <=? (p + m) = true.", "S_nbeq_0": "Theorem S_nbeq_0 : forall n:nat,  (S n) =? 0 = false.", "mult_1_l": "Theorem mult_1_l : forall n:nat, 1 * n = n.", "all3_spec": "Theorem all3_spec : forall b c : bool,    orb      (andb b c)      (orb (negb b)               (negb c))  = true.", "mult_plus_distr_r": "Theorem mult_plus_distr_r : forall n m p : nat,  (n + m) * p = (n * p) + (m * p).", "mult_assoc": "Theorem mult_assoc : forall n m p : nat,  n * (m * p) = (n * m) * p.", "eqb_refl": "Theorem eqb_refl : forall n : nat,  true = (n =? n).", "plus_swap'": "Theorem plus_swap' : forall n m p : nat,  n + (m + p) = m + (n + p).", "nat_bin_nat": "Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.", "surjective_pairing'": "Theorem surjective_pairing' : forall (n m : nat),  (n,m) = (fst (n,m), snd (n,m)).", "surjective_pairing_stuck": "Theorem surjective_pairing_stuck : forall (p : natprod),  p = (fst p, snd p).", "surjective_pairing": "Theorem surjective_pairing : forall (p : natprod),  p = (fst p, snd p).", "snd_fst_is_swap": "Theorem snd_fst_is_swap : forall (p : natprod),  (snd p, fst p) = swap_pair p.", "fst_swap_is_snd": "Theorem fst_swap_is_snd : forall (p : natprod),  fst (swap_pair p) = snd p.", "bag_theorem": "Theorem bag_theorem : ...", "nil_app": "Theorem nil_app : forall l : natlist,  [] ++ l = l.", "tl_length_pred": "Theorem tl_length_pred : forall l:natlist,  pred (length l) = length (tl l).", "rev_length_firsttry": "Theorem rev_length_firsttry : forall l : natlist,  length (rev l) = length l.", "rev_length": "Theorem rev_length : forall l : natlist,  length (rev l) = length l.", "app_assoc4": "Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.", "nonzeros_app": "Lemma nonzeros_app : forall l1 l2 : natlist,  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).", "eqblist_refl": "Theorem eqblist_refl : forall l:natlist,  true = eqblist l l.", "count_member_nonzero": "Theorem count_member_nonzero : forall (s : bag),  1 <=? (count 1 (1 :: s)) = true.", "leb_n_Sn": "Theorem leb_n_Sn : forall n,  n <=? (S n) = true.", "remove_does_not_increase_count": "Theorem remove_does_not_increase_count: forall (s : bag),  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.", "rev_injective": "Theorem rev_injective : forall (l1 l2 : natlist),    rev l1 = rev l2 -> l1 = l2.", "option_elim_hd": "Theorem option_elim_hd : forall (l:natlist) (default:nat),  hd default l = option_elim default (hd_error l).", "eqb_id_refl": "Theorem eqb_id_refl : forall x, true = eqb_id x x."}